## Dubbo

Q1:为什么要进行系统拆分？如何进行系统拆分？拆分后不用 dubbo 可以吗？

等价于分布式的好处:1.提高开发效率和降低维护成本; 2.提高并发性能

```
因为系统业务可能越来越复杂,对于一个大型系统,动则几十万行代码,如果不拆分,维护成本很高.
对系统的拆分一般会根据业务类型,先进行一轮拆分.比如电商网站有用户系统,商品系统,订单系统等.然后在业务拓展中,一个系统可能会越来越复杂,从而又要进行拆分.
可以.那就是基于http协议的SpringMVC接口之间的调用.但是Dubbo作为RPC框架,让我们能够在本地远程调用接口,并且帮助实现负载均衡和监控等
```

### Dubbo原理

Q:说一下的 dubbo 的工作原理？注册中心挂了可以继续通信吗？说说一次 rpc 请求的流程？

````
dubbo是一种分布式服务框架,提供高性能和透明化的RPC远程服务调用方案.使用dubbo可以
	透明化的使用远程服务,只用简单配置,没有API侵入
	软负载均衡以及集群容错机制
	服务自动注册和发现.
注册中心挂了还可以继续通信,因为初始化的时候,消费方会将提供方的地址信息缓存到本地
````

![1553697121741](d:/resource/notePic/1553697121741.png)

````
1.启动时,服务提供方往注册中心注册,消费方往注册中心订阅服务地址列表
2.当服务地址列表发生变更时,注册中心会基于长连接通知消费方
3.消费方代理会根据负载均衡策略调用一个服务地址
4.服务方和消费方通过异步的方式往监控中心发送数据,频率是每分钟一次,不是基于长连接
````

![1553913851886](d:/resource/notePic/1553913851886.png)

### Dubbo支持的通信协议

Q:dubbo 支持哪些通信协议？支持哪些序列化协议？说一下 Hessian 的数据结构？PB 知道吗？为什么 PB 的效率是最高的？

````
dubbo默认采用dubbo通信协议,单一长连接,进行NIO异步通信.基于hessian作为序列化协议.使用场景是数据量小,并发量高.
dubbo还支持rmi协议,hessian协议,http协议(json序列化)
````

```
PB:Protocol Buffer,类似于Json和Xml的一种数据存储格式,其性能更好,主要有两个原因:1.使用Proto编译器自动序列化和反序列化,速度更快;2.数据压缩效果好,因此传输量小,速度更快
```

### Dubbo的负载均衡策略和集群容错策略

```
负载均衡策略
random loadbalance:随机发送请求,可以为机器分配权重
roundrobin loadbalance:均匀发送请求,可以为机器分配权重
leastactive loadbalance:自动感知发送请求,机器性能越差,分配的请求越少
consistenthash loadbalance:一致性哈希发送请求,通过虚拟节点技术提升扩展性,相同参数的请求一定会发送到同一个机器上
```

`````
集群容错策略
failover cluster模式:失败自动切换机器,常见于读操作
failfast cluster模式:一次调用失败即失败,常见于写操作
failsafe cluster模式:出现异常时忽略掉,常用于不重要接口的调用,如记录日志
failback cluster模式:失败后自动后台记录请求,然后定时重发,常用于MQ
forking cluster模式:并行调用多个provider,成功一个即返回
broadcast cluster模式:遍历调用所有的provider
`````

````
动态代理策略:dubbo的服务端和客户端通信其实都是通过代理类实现
dubbo使用javassist动态字节码生成技术,创建代理类(socket)
````

### Dubbo的spi思想是什么?

```
SPI:service provider interface
其思想是提供很多标准接口,但是这些接口可以有很多实现类,具体每次调用服务的时候,使用哪一个实现类,可以配置决定.运用spi思想,可以很方便的自定义dubbo,加入一些自己的插件.
类似于java提供了JDBC接口,mysql和oracle都有一套自己的实现类
```

### Dubbo的服务治理,服务降级和失败重试?

```
服务治理:介绍两个,调用链路自动生成和统计服务访问压力及时长. 当服务很多时,它们之间的调用关系很复杂,可以通过dubbo的服务治理自动生成调用链路图,就可以清晰的知道服务之间的调用关系. 并且每个服务的每个接口每天被调用的次数以及请求延时都会被记录.从源头开始,一个完整请求经过的所有服务构成的服务链,每天的访问次数和请求延时也会被记录.通过分析这些记录,就可以知道不同服务的访问压力.
```

`````
服务降级:当A服务调用B服务,多次调用失败后,会采用B服务降级,即走一个备用逻辑,返回给用户.
失败重试和超时重试:访问一个接口失败或者超时没有收到回复后的重试次数都可以配置.
`````

### 分布式服务接口的幂等性?

Q:分布式服务接口的幂等性如何设计（比如不能重复扣款）？

````
和消息队列的幂等性一样,需要结合具体业务来.比如订单付款请求过来后,应该根据订单id,先往redis或mysql中插入一条流水id,如果这个id已经存在,表明这个请求已经来过一次,就不会再次扣款了.
````

### 分布式服务接口的顺序性?

Q:分布式服务接口请求的顺序性如何保证？

````
一般来说,分布式服务接口是不需要保持请求的顺序性的.如果一定要保证顺序性可以用分布式锁,但是会提高系统复杂度,降低效率;或者请求分到了某个机器上后,将其塞入内存队列,强制排队,这样也会降低效率.因此最好从业务逻辑上改进,使得不同请求不用保证顺序性.
````

### 自己设计一个RPC框架

Q:如何自己设计一个类似 Dubbo 的 RPC 框架？

```
这类问题,其实就是照着熟悉的Dubbo模型去说
1.首先需要一个分布式注册中心,保留各个服务的信息,可以用zookeeper实现
2.消费者需要去注册中心获取服务信息,并且每个服务可能有多个地址
3.消费者通过动态代理发送请求,这个动态代理会找到服务对应的地址
4.发送请求需要用到负载均衡策略,可以用随机轮询
5.发送请求使用nio方式,序列化使用hessian序列化协议
6.服务提供者也需要针对自己的服务,生成一个动态代理,它监听某个网络端口,当请求来的时候,动态代理就会调用相应的业务代码
```

### ProtoBuf 序列化协议为什么这么快？

主要原因是 protobuf 序列化后的文件存储体积小，以及序列化/反序列化的速度快。

序列化体积小是因为 protobuf 牺牲了序列化后的可读性，指定了很多规则来序列化，以最大化压缩信息传输空间。

比如对结构化对象的字段名称还有字段长度的存储，protobuf 是通过生成一个 proto 文件，来用简单的序列号来标记这些信息。

[参考](https://cloud.tencent.com/developer/article/1520442)
