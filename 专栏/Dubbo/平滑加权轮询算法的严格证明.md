## 平滑加权轮询算法的严格证明

**为什么需要平滑加权轮询算法？**

比如，服务器 [A, B, C] 对应权重 [5, 1, 1]。进行7次负载均衡后，选择出来的序列为 [A, A, A, A, A, B, C]。前5个请求全部都落在了服务器 A上，这将会使服务器 A 短时间内接收大量的请求，压力陡增。而 B 和 C 此时无请求，处于空闲状态。而我们期望的结果是这样的 [A, A, B, A, C, A, A]，不同服务器可以穿插获取请求。

平滑加权轮询算法能够实现这样的“穿插”效果。



**平衡轮询算法具体怎么操作？**

每个服务器对应两个权重，分别为 weight 和 currentWeight。其中 weight 是固定的，currentWeight 会动态调整，初始值为0。当有新的请求进来时，遍历服务器列表，让它的 currentWeight 加上自身权重。遍历完成后，找到最大的 currentWeight，并将其减去权重总和，然后返回相应的服务器即可。举例如下

| 请求次数 | currentWeight 数组 | 选择结果 |
| -------- | ------------------ | -------- |
| 1        | [5, 1, 1]          | A        |
| 2        | [3, 2, 2]          | A        |
| 3        | [1, 3, 3]          | B        |
| 4        | [6, -3, 4]         | A        |
| 5        | [4, -2, 5]         | C        |
| 6        | [9, -1, -1]        | A        |
| 7        | [7, 0, 0]          | A        |
| 8        | [5, 1, 1]          | ...      |

如上，经过平滑性处理后，得到的服务器序列为 [A, A, B, A, C, A, A]，相比之前的序列 [A, A, A, A, A, B, C]，分布性要好一些。初始情况下 currentWeight = [0, 0, 0]，第7个请求处理完后，currentWeight 再次变为 [0, 0, 0]。



**证明平衡轮询算法要证明什么问题？**

假设目前一共有n个服务，它们的权值分别为[x11, x12, x13, ... , x1n]，记所有的权值和为S。需要证明两个问题：

1. **轮询本义**：在S中次负载均衡中，服务 i 的权重为x1i，所以它需要被选择x1i次
2. **平滑**：服务 i 的权重为x1i，它不可能连续x1i次被选中



### 证明过程

网上搜一下平滑加权轮询算法的证明，大部分都是[这个版本](https://tenfy.cn/2018/11/12/smooth-weighted-round-robin/)的复制粘贴，这个版本在证明**轮询本义**的时候是正确的，但是描述的不是太清晰，但是其证明**平滑**的过程是不严谨的，它只是证明了服务i从第一次开始不可能连续被选择x1i次，但是连续出现的次数不一定要在第一次开始，如果没有了第一次就开始连续出现的假设，证明过程就是不对的。

假设目前一共有n个服务，它们的权值分别为[x11, x12, x13, ... , x1n]，既所有的权值和为S。

证明之前，先描述一个小规律。从平滑轮询的过程可以看到，每次选择了一个结果后，被选中的currentWeight需要减去S，相当于整个currentWeight的数组和就变成了0；而在下一次开始选择时，currentWeight数组每个元素都加上初始权值weight ，对于整个currentWeight数组而言，其和又变成了S。所以每一次被选中的currentWeight减去的值都是S，固定不变的。

每个元素在每一次选择中，只有两个结果：选中 or 没选中。所以可以得到currentWeight[i]的递推式：

```java
currentWeight[i] = currentWeight[i - 1] + xi; // 在第i-1次选择时服务i没被选中
currentWeight[i] = currentWeight[i - 1] + xi - S; // 在第i-1次选择时服务i被选中
```

简单来说，currentWeight数组中每个元素相当于上一次选择来说，要么加`xi`， 要么加`xi - S`

有了以上基础，我们可以开始证明了。

#### 轮询本义证明

假设服务 i 在 t 次选择后，已经被选中了 x1i 次，现在需要证明在 t 次以后的所有选择中，服务 i 都不可能再被选中

t 次选择（t < S），被选中了 xi 次，没被选中 t -  xi 次，所以 t + 1次开始选择前，它的权值为

```
w = xi * (xi - S) +  (t -  xi) * xi = (t - S) * xi
```

而t < S恒成立，所以w < 0恒成立。则在t + 1次它不会再被选择。当然这还不够，因为它可能在剩下的其他选择中可能还会被再次选择。只要后面再被选择一次我们的证明就不成立，为了达到目的，需要t尽可能大，所以直接跳到最后一次选择开始时，假设这中间的所有选择服务 i 都没有被选中，最后一次服务 i 的权值w显然是最大的。此时有

```
w = (t - S) * x1i + (S - t) * x1i = 0
```

可以发现，它最大currentWeight才是0，而每次选择前总currentWeight永远是S，所以currentWeight = 0不可能是最大的，服务 i 不可能再被选中。

因此，我们证明了服务 i 最多出现x1i次。因为服务 i 并没有特殊性，所以任意服务 j 也最多出现 x1j 次，最终所有出现的次数和必须为S，所以任意服务 i 最多也必须出现 x1i 次。至此，**轮询本义**证明完成。