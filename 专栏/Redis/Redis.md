## Redis

> Redis是一种开源的,基于内存的数据结构存储,一般用于缓存.

Redis是nosql(非关系型数据库), 关系型数据库采用二维表存储数据, nosql采用键值对存储数据. 并且Redis是基于内存的数据库, 读写速度很快, 但是因为存在较大的丢失风险(虽然有持久化方案), 因此Redis用作缓存(分布式, 高并发的使用场景), 最终存储数据还是得用传统的关系型数据库.

Jedis是集成了Redis的一些常用命令, 对Redis进行封装的Java客户端. 但是一般也不会直接使用Jedis, 而是对它再进行一次封装, 提供API在业务中使用.



### Redis常用的数据结构

Redis存储数据的形式是<k,v>形式, k一定是String类型,v类型有:string / list / hash / set / sortset. [参考](http://jinguoxing.github.io/2018/09/02/redis-data-structures/)

#### string(字符串)

字符串 string 是 Redis 最简单的数据结构。Redis没有Int、Float、Boolean等数据类型的概念，所有的基本类型在Redis中都以String体现。

**使用场景**

- 缓存用户信息: 将用户信息结构体使用 JSON 序列化成字符串，然后将序列化后的字符串塞进 Redis 来缓存。同样，取用户信息会经过一次反序列化的过程。

**内部结构**

- Redis 的字符串是动态字符串（SDS），是可以修改的字符串,内部结构实现上类似于 Java 的 ArrayList，采用预分配冗余空间的方式, 来减少内存的频繁分配
- 当字符串长度小于 1M 时，扩容都是加倍现有的空间，如果超过 1M，扩容时一次只会多扩 1M 的空间, 注意字符串最大长度为 512M

**与String相关的常用命令**

- SET：为一个key设置value，可以配合EX/PX参数指定key的有效期，通过NX/XX参数针对key是否存在的情况进行区别操作，时间复杂度O(1)
- GET：获取某个key对应的value，时间复杂度O(1)
- GETSET：为一个key设置value，并返回该key的原value，时间复杂度O(1)
- MSET：为多个key设置value，时间复杂度O(N)
- MSETNX：同MSET，如果指定的key中有任意一个已存在，则不进行任何操作，时间复杂度O(N)
- MGET：获取多个key对应的value，时间复杂度O(N)

Redis的基本数据类型只有String，但Redis可以把String作为整型或浮点型数字来使用，主要体现在INCR、DECR类的命令上：

- INCR：将key对应的value值自增1，并返回自增后的值。只对可以转换为整型的String数据起作用。时间复杂度O(1)
- INCRBY：将key对应的value值自增指定的整型数值，并返回自增后的值。只对可以转换为整型的String数据起作用。时间复杂度O(1)
- DECR/DECRBY：同INCR/INCRBY，自增改为自减。

INCR/DECR系列命令要求操作的value类型为String，并可以转换为64位带符号的整型数字，否则会返回错误。

Redis采用单线程模型，**天然是线程安全**的，这使得INCR/DECR命令可以非常便利的实现**高并发**场景下的精确控制

#### list（列表）

列表的存储结构用的是链表而不是数组，而且链表还是**双向链表**。当列表弹出了最后一个元素之后，该数据结构自动被删除，内存被回收。

**使用场景**

- Redis 的列表结构常用来做异步队列使用。将需要延后处理的任务结构体序列化成字符串塞进 Redis 的列表，另一个线程从这个列表中轮询数据进行处理。

**内部结构**

- Redis 底层存储的还不是一个简单的 linkedlist, list数据量较小时会使用一块连续的内存存储，这个结构是 ziplist(压缩列表), 当数据量比较多的时候会改成 quicklist(快速链表)
- quicklist 是将多个 ziplist 使用双向指针串起来使用

**与List相关的命令**

- LPUSH：向指定List的左侧（即头部）插入1个或多个元素，返回插入后的List长度。时间复杂度O(N)，N为插入元素的数量
- RPUSH：同LPUSH，向指定List的右侧（即尾部）插入1或多个元素
- LPOP：从指定List的左侧（即头部）移除一个元素并返回，时间复杂度O(1)
- RPOP：同LPOP，从指定List的右侧（即尾部）移除1个元素并返回
- BLPOP / BRPOP: 实现类似于BlockingQueue的能力，即在List为空(key/value不存在)时，阻塞该连接，直到List中有对象可以出队时再返回
- LPUSHX/RPUSHX：与LPUSH/RPUSH类似，区别在于，LPUSHX/RPUSHX操作的key如果不存在，则不会进行任何操作
- LLEN：返回指定List的长度，时间复杂度O(1)
- LRANGE：返回指定List中指定范围的元素（双端包含，即LRANGE key 0 10会返回11个元素），时间复杂度O(N)。应尽可能控制一次获取的元素数量，一次获取过大范围的List元素会导致延迟，同时对长度不可预知的List，避免使用LRANGE key 0 -1这样的完整遍历操作。
- LINDEX：返回指定List指定index上的元素，如果index越界，返回nil。index数值是回环的，即-1代表List最后一个位置，-2代表List倒数第二个位置。时间复杂度O(N)
- LSET：将指定List指定index上的元素设置为value，如果index越界则返回错误，时间复杂度O(N)，如果操作的是头/尾部的元素，则时间复杂度为O(1)
- LINSERT：向指定List中指定元素之前/之后插入一个新元素，并返回操作后的List长度。如果指定的元素不存在，返回-1。如果指定key不存在，不会进行任何操作，时间复杂度O(N)

#### hash(字典)

hash 结构也可以用来存储用户信息，不同于字符串一次性需要全部序列化整个对象，hash 可以对用户结构中的每个字段单独存储。

这样当我们需要获取用户信息时可以进行部分获取。而以整个字符串的形式去保存用户信息的话就只能一次性全部读取，这样就会比较浪费网络流量。缺点是hash 结构的存储消耗要高于单个字符串

**使用场景**

- 存储结构化的信息

**内部结构**

- hash是无序字典, 相当于 Java 语言里面的 HashMap, 实现结构同样是数组 + 链表二维结构, 不同的是，Redis 的字典的值只能是字符串

- 采用渐进式 rehash 策略: 在 rehash 的同时，保留新旧两个 hash 结构，查询时会同时查询两个 hash 结构，然后在后续的定时任务中以及 hash 操作指令中，循序渐进地将旧 hash 的内容一点点迁移到新的 hash 结构中。当搬迁完成了，就会使用新的hash结构取而代之。

    Redis 这样做的好处是高性能，不堵塞服务

**与Hash相关的常用命令**

- HSET：将key对应的Hash中的field设置为value。如果该Hash不存在，会自动创建一个。时间复杂度O(1)
- HGET：返回指定Hash中field字段的值，时间复杂度O(1)
- HMSET/HMGET：同HSET和HGET，可以批量操作同一个key下的多个field，时间复杂度：O(N)，N为一次操作的field数量
- HSETNX：同HSET，但如field已经存在，HSETNX不会进行任何操作，时间复杂度O(1)
- HEXISTS：判断指定Hash中field是否存在，存在返回1，不存在返回0，时间复杂度O(1)
- HDEL：删除指定Hash中的field（1个或多个），时间复杂度：O(N)，N为操作的field数量
- HINCRBY：同INCRBY命令，对指定Hash中的一个field进行INCRBY，时间复杂度O(1)
- HGETALL：返回指定Hash中所有的field-value对。返回结果为数组，数组中field和value交替出现。时间复杂度O(N)
- HKEYS/HVALS：返回指定Hash中所有的field/value，时间复杂度O(N)

#### set(集合)

Redis的集合，它内部的键值对是无序的唯一的。

当集合中最后一个元素移除之后，数据结构自动删除，内存被回收。

**使用场景**

- set 结构可以用来存储活动中奖的用户 ID，因为有去重功能，可以保证同一个用户不会中奖两次。

**内部结构**

- 相当于一个特殊的字典，字典中所有的 value 都是一个值NULL。

**与Set相关的命令**

- SADD：向指定Set中添加1个或多个member，如果指定Set不存在，会自动创建一个。时间复杂度O(N)，N为添加的member个数
- SREM：从指定Set中移除1个或多个member，时间复杂度O(N)，N为移除的member个数
- SRANDMEMBER：从指定Set中随机返回1个或多个member，时间复杂度O(N)，N为返回的member个数
- SPOP：从指定Set中随机移除并返回count个member，时间复杂度O(N)，N为移除的member个数
- SCARD：返回指定Set中的member个数，时间复杂度O(1)
- SISMEMBER：判断指定的value是否存在于指定Set中，时间复杂度O(1)
- SMOVE：将指定member从一个Set移至另一个Set
- SMEMBERS：返回指定Hash中所有的member，时间复杂度O(N)
- SUNION/SUNIONSTORE：计算多个Set的并集并返回/存储至另一个Set中，时间复杂度O(N)，N为参与计算的所有集合的总member数
- SINTER/SINTERSTORE：计算多个Set的交集并返回/存储至另一个Set中，时间复杂度O(N)，N为参与计算的所有集合的总member数
- SDIFF/SDIFFSTORE：计算1个Set与1或多个Set的差集并返回/存储至另一个Set中，时间复杂度O(N)，N为参与计算的所有集合的总member数

#### zset(有序集合)

Redis Sorted Set是有序的、不可重复的String集合。

一方面它是一个 set，保证了内部 value 的唯一性，另一方面它可以给每个 value 赋予一个 score，代表这个 value 的排序权重。它的内部实现用的是一种叫做「跳跃列表」的数据结构。

zset 中的每个元素都需要指派一个分数(score)，zset 会根据score对元素进行升序排序。如果多个member拥有相同的score，则以字典序进行升序排序。

zset 中最后一个 value 被移除后，数据结构自动删除，内存被回收。

zset 非常适合用于实现排名。

**使用场景**

- zset 可以用来存粉丝列表，value 值是粉丝的用户 ID，score 是关注时间。我们可以对粉丝列表按关注时间进行排序
- zset 还可以用来存储学生的成绩，value 值是学生的 ID，score 是他的考试成绩。我们可以对成绩按分数进行排序就可以得到他的名次。

**内部结构**

- 内部实现使用了「跳跃列表」([什么是跳表](#跳表))

**与Sorted Set相关的命令**

- ZADD：向指定Sorted Set中添加1个或多个member，时间复杂度O(Mlog(N))，M为添加的member数量，N为Sorted Set中的member数量
- ZREM：从指定Sorted Set中删除1个或多个member，时间复杂度O(Mlog(N))，M为删除的member数量，N为Sorted Set中的member数量
- ZCOUNT：返回指定Sorted Set中指定score范围内的member数量，时间复杂度：O(log(N))
- ZCARD：返回指定Sorted Set中的member数量，时间复杂度O(1)
- ZSCORE：返回指定Sorted Set中指定member的score，时间复杂度O(1)
- ZRANK/ZREVRANK：返回指定member在Sorted Set中的排名，ZRANK返回按升序排序的排名，ZREVRANK则返回按降序排序的排名。时间复杂度O(log(N))
- ZINCRBY：同INCRBY，对指定Sorted Set中的指定member的score进行自增，时间复杂度O(log(N))
- ZRANGE/ZREVRANGE：返回指定Sorted Set中指定排名范围内的所有member，ZRANGE为按score升序排序，ZREVRANGE为按score降序排序，时间复杂度O(log(N)+M)，M为本次返回的member数
- ZRANGEBYSCORE/ZREVRANGEBYSCORE：返回指定Sorted Set中指定score范围内的所有member，返回结果以升序/降序排序，min和max可以指定为-inf和+inf，代表返回所有的member。时间复杂度O(log(N)+M)
- ZREMRANGEBYRANK/ZREMRANGEBYSCORE：移除Sorted Set中指定排名范围/指定score范围内的所有member。时间复杂度O(log(N)+M)

#### 容器型数据结构的通用规则

list / hash /set / zset 这四种数据结构是容器型数据结构，它们共享下面两条通用规则：

- create if not exists

    如果容器不存在，那就创建一个，再进行操作。比如 rpush 操作刚开始是没有列表的，Redis 就会自动创建一个，然后再 rpush 进去新元素。

- drop if no elements

    如果容器里元素没有了，那么立即删除元素，释放内存。这意味着 lpop 操作到最后一个元素，列表就消失了…

#### 其它通用规则

- Redis会共享0~9999的字符串对象
- 对象会记录自己最后一次被访问的时间

#### 常见面试问题

Q：Redis 为什么使用 SDS（simple dynamic string）做字符串结构，而不使用 c 语言的字符串结构

```
SDS 中维护了字符数组，还有使用长度和剩余使用长度，有以下好处：
- 获取字符串长度只用使用 O(1) 的时间复杂度，而 c 语言由于需要遍历，是 O(N) 的时间复杂度
- 字符串拼接时，可能会减少内存分配次数
- 避免字符串拼接时内存区的溢出（因为会校验剩余长度 free 是否够用），而 c 语言如果粗心未分配内存，可能会导致缓冲区覆盖
```





### RedisObject

redis中key都是使用sds(simple dynamic string)存储，而value其实都是使用RedisObject包装，它包含有属性：type(数据类型) / encoding(数据类型的编码方式) / lru(最近一次被访问的时间) / refcount(被引用次数) / ptr(指向的数据对象)

#### type

声明value是redis支持的5种数据结构中的某一种

#### encoding

redis5种数据结构，每种都至少有2种内部编码方式，不同的编码方式有不同的使用场景。如列表有ziplist和quicklist两种，ziplist使用连续内存，适用于小数据量列表的存储，查找效率快；而quicklist是将ziplist使用链表连接，适用于大数据量列表存储(因为大容量连续内存难找)

#### lru

记录对象最后一次被访问的时间，使用`object idletime [key]`即可查询某个key的空转时间(当前时间 - lru)，在内存淘汰机制中，若使用allkeys-lru策略，则会优先淘汰空转时间长的key

#### refcount

记录对象被引用的次数，redis中对一些共享对象不重复存储。比如redis在启动时，会加载0~9999的字符串共享

#### ptr

指向实际存储的数据



### 应用场景

- 缓存
- 分布式锁
- 简单的消息队列
- session 共享
- 排行榜
- 计数器（点赞）



### 跳表

[参考](https://www.jianshu.com/p/d12389b80a19)

跳表 = 多级索引 + 链表, 它通过将链表提取多级索引, 使得链表也能像数组一样支持"二分查找", 其搜索 / 插入 / 删除的时间复杂度都是O(logN), 代价是多级索引带来了额外O(N)的空间复杂度.

![1565579009027](d:/resource/notePic/1565579009027.png)

但是注意, 索引节点存储的只是索引数据+指针, 而链表中存储的数据在实际开发中往往是非常大的, 这样来看多的O(N)指针空间就可以忽略了.

#### 跳表索引动态更新

当我们不停的往跳表中插入数据时，如果我们不更新索引，就可能出现某 2 个索引结点之间数据非常多的情况。极端情况下，跳表会退化成单链表。

![1565579142292](d:/resource/notePic/1565579142292.png)

作为一种动态数据结构，我们需要某种手段来维护索引与原始链表大小之间的平滑，也就是说如果链表中结点多了，索引结点就相应地增加一些，避免复杂度退化，以及查找、插入、删除操作性能下降。

我们往跳表中插入数据的时候，可以选择同时将这个数据插入到第几级索引中，比如随机函数生成了值 K，那我们就将这个结点添加到第一级到第 K 级这 K 级索引中。

![1565579200926](d:/resource/notePic/1565579200926.png)

#### 为什么不使用红黑树实现zset?

- 范围查询时, 跳表可以首先查询起点, 然后在顺序指针遍历即可. 然而红黑树中值相邻的点物理结构可能很远, 在范围查询时表现不如跳表
- 跳表相当于红黑树来说, 更容易实现
- 跳表可以通过控制索引构建策略, 平衡时间和内存的消耗



### Redis键的过期策略

Redis的内存空间是有限的,所以需要对键设置生存时间(命令expire)或过期时间(命令expireat)

#### 过期清除机制

过期的键仍然保存在hash表中,需要根据过期策略对其进行清理.

````
定时删除:到达了过期时间,键就会被删除.
	对内存友好.但是因为经常要调用CPU的资源,对CPU不友好
惰性删除:当使用这个键时,发现它过期了则删除
	对CPU友好,但是因为有些键过期了后基本不会被用到,所以内存中过期的键会越来越多,占用内存
定期删除:每隔一段时间删除过期键,限制删除时长和频率
	折中方案
````

#### 内存淘汰机制

过期策略一般采用:惰性删除 + 定期删除. 定期删除限制删除时长和频率,所以可能会有很多过期键没被清理,内存长时间就需要一次"淘汰"

````
volatile-lru:在设置过期的键中,删除最近使用最少的键
volatile-ttl:在设置过期的键中,删除快要过期的键
volatile-random:在设置过期的键中,随机删除
allkeys-lru:所有键中,删除最近使用最少的键
allkeys-random:所有键中,随机删除
noeviction:禁止清除数据
````

一般使用的都是allkeys-lru策略,保证数据热度,提高命中率



### Redis的持久化

Redis作为内存中的数据,持久化是其重要保障.避免宕机后丢失大量数据

#### RDB(快照持久化)

将某一个时刻,将所有数据保存到一个RDB文件中,Redis可以根据这个文件恢复数据

RDB可以手动执行:save 和 bgsave. save会阻塞所有请求,直到RDB文件生成完毕.bgsave是在后台创建一个子线程,不妨碍请求到达服务器.也可以配置条件触发,定期执行快照持久化.

服务器在重新启动时,会自动读取RDB文件,并进行数据恢复工作,恢复时会处于阻塞状态.

#### AOF(文件追加)

将数据的所有写命令保存成文件,便于再次执行,恢复数据.

AOF重写可以手动执行:bgrewriteaof,也可以配置触发条件. 手动执行时,为了保持重写后的数据一致性,在重写时会将新的写命令保存在一个缓存区中,重写完成后再将缓存区中的AOF文件更新到磁盘中. 

因此也会存在数据丢失的风险，但是丢失量很小，且可以配置缓存文件同步到磁盘的频率。AOF文件隔一定的时间会重写，主要是删除无效的命令，合并一些命令，用来减少文件的大小。

#### RDB VS AOF

RDB和AOF并不冲突,两者可以同时使用. 如果服务器同时采用了RDB和AOF进行持久化,服务器会优先使用AOF文件恢复数据,因为AOF更新频率更高,还原数据更完善.

````
RDB优点:载入数据块,文件体积小
RDB缺点:数据更新频率相对慢,一旦服务器宕机,期间没有进行RDB的数据就都会丢失
AOF优点:更新频率快,丢失数据少(默认只丢失1s的数据)
AOF缺点:文件体积大,恢复数据速度慢

对于过期键,RDB和AOF在恢复的时候,都会忽略.
````



### Redis线程模型

Redis是事件驱动的单线程模型,主要包含四个部分:多个socket;IO多路复用程序;文件事件分派器;事件处理器(多种).

采用IO多路复用机制,监听多个socket,将产生事件的socket压入内存队列,事件派发器每次取出一个socket,根据socket产生事件的类型,调用不同的事件处理器进行处理.

#### 文件事件

![1553652229553](d:/resource/notePic/1553652229553.png)

```
I/O多路复用的特点: 一个进程能同时等待多个文件描述符，而这些文件描述符其中的任意一个进入读就绪状态，select()函数就可以返回。
select/epoll的优势并不是对于单个连接能处理得更快，而是在于能处理更多的连接。
```

#### 时间事件

时间事件是对**定时操作**的抽象,RDB AOF 和 键的删除都是通过触发时间事件调用函数完成

Redis服务器将时间事件放在一个**链表**中，当时间事件执行器运行时，会遍历整个链表。

#### 文件事件  VS  时间事件

两者是合作关系,服务器会轮流处理这两种事件.并且处理过程中,不会发生抢占.

#### 为什么Redis是单线程还这么快?

````
1.因为Redis是纯内存操作
2.单线程避免了多线程的频繁上下文切换
3.其事件处理采用了非阻塞的IO多路复用机制
	多路复用:一个进程能够同时等待多个文件描述符,任意一个文件描述符都可以触发事件发生
````



### Redis主从复制

为了保证Redis的高可用性,一般采用主从架构,主服务器负责写,从负责读,从数据都是从主复制得到

从服务器复制时包含两个过程:同步和命令传播.第一次复制时是同步,以后都是主服务器将写操作通过命令传播发送给从服务器

#### 同步

完整重同步:从服务器向主服务器发送PSYNC命令,收到命令后的主服务器在后台执行bgsave命令,生成一个RDB文件,并用缓冲区记录之后的写命令.然后将RDB文件发送给从服务器,从服务器接收并载入RDB文件.最后主服务器将缓冲区的所有写命令发送给从服务器,从服务器执行这些写命令.最终达到数据的一致性

部分重同步:从服务器和主服务器在同步时,可能会出现断线重连的情况.通过主从服务器的复制偏移量来判断这种情况.发生这种情况时,主服务器会检查其复制积压缓冲区中是否存在从服务器因为断线丢失的数据,如果存在就会部分重同步,不存在就完整重同步. 

当然,断线重连后,还会比较服务器运行ID,如果主服务器ID变化,表明重连后的主服务器发生了变化,此时必须完整重同步

#### 命令传播

当完成了同步之后，主从服务器就会进入命令传播阶段。这时主服务器只要将自己的写命令发送给从服务器，而从服务器接收并执行主服务器发送过来的写命令，就可以保证主从服务器一直保持数据一致了！

命令传播阶段,从服务器每秒钟会给主服务器发送自己的复制偏移量.以检测主从服务器的网络状态.(如果判断是断线重连,就需要判断是否需要部分重同步或完整重同步)



### Redis哨兵机制

当主服务器出现故障断线后,哨兵(Sentinel)机制会将某一个从服务器选为新的主服务器,其他从服务器该从新的主服务器中进行命令传播,旧的主服务器若重新上线,则会成为一个从服务器.

![1553660870631](d:/resource/notePic/1553660870631.png)

Sentinel本质是运行在特殊模式下的Redis服务器,为了保证高可用性,它也是多个的.但是它的作用就是监视主从服务器,不具有Redis的一些命令.

#### Sentinel的初始化

````
1.根据配置文件,创建连向主服务器的网络连接:命令连接和订阅连接.
2.通过往主服务器发送命令,获取主服务器属下所有从服务器的地址信息,并为这些从服务器创建相应的实例.
3.同样为这些实例结构创建网络连接:命令连接和订阅连接.
````

通过创建的命令连接,Sentinel每隔2s就会发送一次命令,并通过订阅连接接收回答.通过两个连接不断更新所有实例的相关信息

#### Sentinel监测主服务器下线

**主观下线:**Sentinel会每隔1s向与它创建命令的所有实例(包括主从服务器和其他Sentinel)发送Ping命令,如果主服务器在指定时间(可配置大小)内回复的都是无效信息.则该Sentinel判断其主观下线

**客观下线:**当Sentinel判断主服务器主观下线,为了确认,会询问其他Sentinel是否也认为其主观下线,当有指定数量(可配置大小)的Sentinel认为其主观下线,则会认为其客观下线,开始准备选举新的主服务器

#### Sentinel选举新的主服务器

Sentinel判断主服务器主观下线后,会选举出一个Sentinel进行故障转移,选举策略一般是先到先得.

Sentinel选举新的主服务器,会根据从服务器的信息,执行一定的策略挑选.(比如和master断开连接的时长,slaves优先级)

````
虽然有主从复制和哨兵机制保障Redis的高可用性,但是它还是会存在数据丢失的可能.比如命令传播过程中主机宕机或"脑裂"
````



### 缓存雪崩

缓存雪崩是指缓存失效,导致请求走数据库的情况. 其发生的情况有

```
1.缓存过期时间都设置相同值,在某一时刻缓存会全部失效
2.Redis主服务器挂掉
```

对应的解决措施

```
1.每次过期时间加上一个随机值,避免同时过期
2.事发前:主从结构+哨兵机制,避免主服务器挂掉;事发时:本地缓存和限流机制保障DB安全;事发后:快速故障转移
```

#### 限流算法

1. 令牌桶算法:系统以固定的速度往桶里放令牌,桶如果满了,新增的令牌会被丢弃.当请求需要处理时,需要先从桶中消费一个令牌, 如果桶为空,则拒绝请求.
2. 漏桶算法:滴入桶中的速率任意,但是从桶中出来的水速率固定,桶慢了则新滴入桶中的水会被丢弃.本质是一个长度固定的任务队列
3. 计数器限流算法:简单粗暴,限制总的并发数量,比如数据库连接池,线程池的大小都是采用这种

### 缓存穿透

黑客已知查询数据在数据库中不存在时,大量查询.因为数据库中不存在,所以缓存一定不会被击中.大量的请求就会直接走数据库,即缓存穿透.

解决措施

`````
1.设置过滤器,如布隆过滤器,对请求数据进行过滤
2.在数据库中查询不存在的数据,将其也写入到缓存中,value为null,设置较短的过期时间.
`````



### 缓存击穿

某个热点数据的访问量非常高,在其过期的时间内,大量请求直接走数据库,导致DB崩掉

解决措施:不设置过期时间



### 缓存与数据库数据一致性问题

当进行写(增/改/删)操作时,需要对数据库和缓存中的数据都进行操作,对缓存操作最直接的方式是,无论增改删,直接删除缓存中对应的数据.在下次查询的时候,会重新写入缓存.

但是数据库的写和缓存的删除是两个操作,涉及到分布式事务处理,在高并发时,无论先删除缓存,再写数据库.还是先写数据库,再删除,都会存在数据库与缓存不一致的问题.同时,事务在原子性遭到破坏时,也会导致缓存与数据库数据不一致的问题.

两种方式适用场景不同:

````
先删除缓存再写数据库,其原子性被破坏也不妨碍一致性.
先写数据库再删除缓存,其高并发情况下出现不一致性的概率很小.
````

如果必须要保持缓存和数据库一致的话,需要将读请求和写请求串行化到内存队列中,但是这个会大幅降低系统的吞吐量.



### 分布式锁

#### Red Lock 算法

如果只有一个 master，可能 A 在获取锁成功后，master 还未同步就挂掉了，那么新选的 master 是没有锁的，B 仍然可以获取锁。

为了避免这种情况，会有多个 master（它们锁之间的数据没必要同步），每次获取锁时，要依次从多个 master 中获取锁，只有超过一半数量的 master 获取锁成功才认为成功，所以此时j即使有少量机器宕机，也不影响锁的获取。

#### 可重入

与 JVM/ReentrantLock 实现可重入的原理是一致的，需要记录获取锁的线程以及维护一个计数器。这两个信息都可以通过 value 来保存：

- 获取锁的线程可以使用如下格式：`机器id_进程id_线程id` 唯一定位一个线程
- 计数器：用一个 int 来记录

问题是，每次获取锁时，有多个步骤：

- 看这个 key 是否存在，若不存在则是第一次获取锁
- 若存在，则需要对比线程，判断是否需要重入
- 若需要重入，则需要更新 value 

总的来说，至少需要两次操作（读和写），redis 的两个命令无法保证原子性，所以可以使用 lua 脚本，将其封装成一个新的原子命令，Redisson 提供了这样的支持。

#### 锁的释放

Q：如何保证正常释放锁？（不正常的情况：1.释放时锁已经属于别人；2.释放时锁已经超时）

```
对于问题 1，释放锁时需要验明身份，身份信息作为 key 的 value 值存储，可以有两种标识：
1.基于调用方的信息，比如 MAC地址_机器id_进程id_线程id，优点是调用方无感，缺点是需要保证获取锁和释放锁是同一台机器，同一个线程
2.redis 每次获取锁时，生成一个 UUID 作为锁的 value，调用方需要保存该 value 作为身份标识，缺点是需要调用方去处理锁的 value 值

对于问题 2，超时的锁释放时会自动被 redis 清理，或释放之前就已经清理
```

#### 锁的超时

分布式锁在加锁时，一般都会设置超时时间，这样是为了避免持有锁的一方一直不释放锁，导致其它等待的线程出现死锁。

锁的超时时长设置，一般可以考虑为需要持有锁的平均业务时长，然后加一定的 buffer。

Q：如果 A 线程获取锁后，事务还没有指向完，锁就超时了，此时 B 线程获取锁，两个线程同时操作共享资源会有意外的风险，怎么解决这个问题？

[参考](https://juejin.cn/post/6844903764868988936)

```
可以用锁的续期去解决，具体是开启一个守护线程，守护线程内部会设定一个续期次数，每次续期是先等待一个 2/3 的锁超时时长，等待完毕后，就发送续期命令，如果超过了续期次数，则停止继续续期。
需要外部业务代码在执行事务后手动中断守护线程。

如果续期次数用完了，还没有执行完事务呢？
这种情况的概率很低，需要具体分析该事务有没有可能耗时这么久，因为 RPC 或数据库在指定时间内没拿到数据都可以认为请求失败。如果真的要强保证这种情况，那就需要给这个事务限定一个最长执行时间，超过这个时间则自动抛异常回滚事务（实现是从进入事务开始计时，事务完成后计算事务时间，超时则抛异常回滚）
```





## Redis面试题目

### 为什么要用缓存,有什么好处和问题?

````
缓存的两大好处:高性能,高并发.
	对于耗时且不经常变化的查询结果,将其写入缓存,极大提高了访问速度.
	mysql数据库单机支持的并发量有限,使用缓存可以大大提高并发量.

使用缓存存在的可能问题:缓存雪崩/缓存穿透/缓存击穿;缓存和数据库双写不一致的问题;缓存并发竞争
````



### redis 和 memcached 有什么区别?

memcached  有几个问题限制了它的使用场景：

- 只支持 k-v 结构，且 key 最大限制为 250 字节，value 最大限制为 1MB
- key 的过期时间最长为 30 天
- 不提供持久化和主从同步功能



### redis 的数据类型和适用场景？

````
string:最简单的数据类型,存一些简单的k/v对
hash:存结构化的数据
list:存列表.实现分页查询和不间断的列表
set:自动去重
sortedset:排序的无重列表
````



### redis的过期策略和内存淘汰机制?

````
过期策略:定期删除+惰性删除.
	定期删除是默认每隔200ms,随机选取一些key监查是否过期,如果过期就删除.(注意是随机选择,不是遍历)
	惰性删除:每次从redis中取key时,都会检查是否过期,如果过期就直接删除不返回任何key
内存淘汰机制:当写入新数据时发现内存不够,则启动内存淘汰机制
	noeviction:报错
	allkeys-lru, allkeys-random
	volatile-lru, volatile-random, volatile-ttl:删除设置了过期时间键空间中,过期时间最早的一部分
````



### 如何保证redis的高并发和高可用?

````
高并发:采用主从架构(同步和命令传播),一主多从,主负责写,从负责读.可以撑起高并发.如果想实现高并发的同时,实现高容量,就要使用redis集群
高可用:主从架构+哨兵机制,保障了redis的高可用性.哨兵和所有服务器建立了命令连接和订阅连接,实时监测主服务器是否宕机,哨兵会在主服务器发生故障时,进行故障转移.
````



### Redis持久化机制优缺点和实现?

```
Redis有两种持久化机制:RDB和AOF.
RDB(快照持久化):fork一个子进程,进行后台RDB操作,将当前所有数据都存储成一份快照.
AOF(命令追加):将每条写入命令都作为日志存储,需要恢复的时候重写这些命令即可.

RDB优点:恢复速度更快;更健壮
RDB缺点:因为是周期性冷备份,丢失数据相对较多;如果备份文件较大,在fork子进程的时候,可能会停止服务数ms
AOF优点:恢复数据更完善,丢失更少.
AOF缺点:恢复速度较慢;健壮性不够好,恢复时可能会有bug

当需要恢复数据时,优先采用AOF进行恢复.
```



### Redis的并发竞争问题和解决办法 以及 Redis事务的CAS方案?

````
并发竞争:多客户端并发写一个key,本来先到的后到.或者A读取缓存没有,去数据库中取了旧值,然后B从数据库中修改了这个值并写回了缓存,A再将之前读的旧值写入缓存中.
解决方法:zookeeper实现分布式锁,使同一时刻只有一个系统在操作同一个key

Redis事务的CAS方案:mysql中写入的数据都含有时间戳,因此缓存中的数据也会有时间戳.每次更新缓存时,需要比较更新值的时间戳是不是比缓冲中的更新,如果是才更新.
````



### 如何使用redis实现分布式锁

分布式场景时, 因为程序运行在不同的机器上, 也就是不同主机上的进程, 再使用Java提供的API已经没用了.

分布式锁其实就是创建一个大家都能看得见的变量, 然后通过改变变量的值去获得锁. redis一般都是分布式, 能很好的支持这种场景.

获取锁: 使用setnx命令(set when not exist)设置某个key(锁标志)的value值(一般为当前时间+锁过期时间). 如果这个key之前没有设置过值, 那么setnx命令会设置成功, 返回1, 线程1获得锁。setnx 和 expire命令可以合成一条原子指令

竞争锁: 线程2同样使用setnx命令去设置这个key的value, 但是因为线程1已经设置过, 并且还没有释放, 所以此时setnx命令不会做任何操作, 只会返回0, 告知线程2设置失败, 获取锁失败. 如果线程1释放锁后, 线程2再使用setnx命令去获取锁就和步骤1中一样, 成功获取锁.

释放锁: 线程1在释放锁(删除kv对)时要做两个检查, 第一是它是否还是当前锁的持有者, 第二是该锁的是否在过期时间内. 如果已经过期, 可能其他线程刚好在获取锁, 会造成误删.

防止死锁: 如果线程1所在机器宕机, 锁过期后也是会被, 其他线程是通过get命令不断查询是否过期, 发现过期后使用getset命令更新value值, getset命令在更新值前会获取旧值, 如果发现旧值没有过期, 那么就是有其他线程抢先更新了该key的value, 此时线程会认为获取锁失败, 而继续尝试.



### **1亿个key，有10w个key是以固定已知前缀开头，如何将它们找出来？**

使用keys指令可以扫出指定模式的key列表。

对方接着追问：如果这个redis正在给线上的业务提供服务，那使用keys指令会有什么问题？

这个时候你要回答redis关键的一个特性：redis的单线程的。keys指令会导致线程阻塞一段时间，线上服务会停顿，直到指令执行完毕，服务才能恢复。

这个时候可以使用scan指令，scan指令可以无阻塞的提取出指定模式的key列表，但是会有一定的重复概率，在客户端做一次去重就可以了，但是整体所花费的时间会比直接用keys指令长。



### **使用过Redis做异步队列么，你是怎么用的？**

一般使用list结构作为队列，rpush生产消息，lpop消费消息。当lpop没有消息的时候，要适当sleep一会再重试。

如果对方追问可不可以不用sleep呢？list还有个指令叫blpop，在没有消息的时候，它会阻塞住直到消息到来。

如果对方追问能不能生产一次消费多次呢？使用pub/sub主题订阅者模式，可以实现1:N的消息队列。

如果对方追问pub/sub有什么缺点？在消费者下线的情况下，生产的消息会丢失，得使用专业的消息队列如rabbitmq等。

如果对方追问redis如何实现延时队列？我估计现在你很想把面试官一棒打死如果你手上有一根棒球棍的话，怎么问的这么详细。

但是你很克制，然后神态自若的回答道：使用sortedset，拿时间戳作为score，消息内容作为key调用zadd来生产消息，消费者用zrangebyscore指令获取N秒之前的数据轮询进行处理。



### **如果有大量的key需要设置同一时间过期，一般需要注意什么？**

如果大量的key过期时间设置的过于集中，到过期的那个时间点，redis可能会出现短暂的卡顿现象。一般需要在时间上加一个随机值，使得过期时间分散一些。



### **是否使用过Redis集群，集群的原理是什么？**

Redis Sentinal着眼于高可用，在master宕机时会自动将slave提升为master，继续提供服务。

Redis Cluster着眼于扩展性，在单个redis内存不足时，使用Cluster进行分片存储。



### 为什么 Redis6 之后改用多线程呢？

Redis6 的多线程只是用来执行单个命令的任务，为了加快命令的执行速度，但是命令本身还是单线程执行的

