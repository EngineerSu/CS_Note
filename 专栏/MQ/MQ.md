## MQ

![1553919712032](d:/resource/notePic/1553919712032.png)

### 消息队列有什么优缺点,有哪些MQ?

````
优点:解耦,异步,削峰.解耦使系统拓展性变强,异步配合业务逻辑让用户体验更好,削峰保障了DB的安全.
	消息队列的优点也是为什么使用消息队列的原因
缺点:系统复杂度变高;系统可用性降低(MQ挂掉整个系统就挂掉);一致性问题(异步的时候怎么保证消息队列的返回值和最终消息被消费后的结果一致)
````

### 如何保证消息队列的高可用性

除了Kafka,其他消息队列都不是真的分布式消息队列.这里举例RabbitMQ和Kafka的HA实现机制

````
RabbitMQ-HA:镜像集群模式(主从架构).多台机器上的RabbitMQ节点都保存一个queue,数据完全一致,写的时候写一个节点,然后同步到其他所有实例的queue中,读的时候都可以读.
镜像集群模式提高了系统的吞吐量,但是可扩展性差,新增一台服务器它需要同步所有的queue数据,资源消耗大

Kafka-MQ:Kafka集群中的节点称为broker,每个topic在存储时会被划分为多个partition,每个partition一共有三份一样的复制品.存储在不同的broker中.针对一个topic,会选举出来一个broker作为leader,其他存放节点作为follower,生产者写入的时候是在leader节点中写入,然后同步到其他节点中.只有同步完成的消息才能被消费者获取.如果leader所在的节点挂了,会选其他的节点作为leader.kafka的集群保证了高并发性和高可用性.
````

### 如何保证消息不被重复消费(消费的幂等性)

消息被重复消费在所有的MQ中都是存在的,因为需要开发者去避免这种情况.

`````
以Kafka为例,生产者每生产一个消息,MQ都会为其添加一个offset(类似于序列号),消费者会定期将消费消息的offset提交给MQ,这样下次MQ提供消息的时候就会知道从哪里开始继续提供.但是如果消费者还没提交已经消费的offset,就重启了,那么就可能会出现重复消费.
避免消息重复消费要结合具体业务,比如是在数据库中插入消息,如果主键已经存在就改为更新;比如往redis中写入消息,天然幂等性(所有都是更新)等.即虽然消息还是重复消费了,但是不影响正确的数据结果.
`````

### 如何保证消息的可靠性传输(不丢失)

消息丢失可能发生在 生产者->MQ MQ宕机 MQ->消费者 三个环节中.

````
生产者->MQ丢失:confirm保障机制.Rabbit的MQ持久化成功后 | Kafka的MQfollower全部同步成功后,会给生产者发送ack数据包确认,如果没有发送,生产者一定时间后会重发消息
MQ宕机: Rabbit的主从架构高可用,多个从可以替代. Kafka的分布式高可用,如果leader宕机,重新选举
MQ->消费者: confirm保障机制. Rabbit的MQ关闭消费者自动ack,让消费者手动代码ack. Kafka关闭消费者自动提交offset,也是消费后手动代码提交offset.
````

### 如何保证消息的顺序传输

比如一条数据的增/改/删在生产者那里顺序生产,但是消费者那里可能不是顺序执行

````
解决办法是,将需要注意顺序的消息设为有相同的key,queue将key相同的消息在同一个队列,同一个queue的消息也只会被同一个线程消费.相当于单线程消费,保证了顺序
````

### 实际问题

Q1:如何解决消息队列的延时以及过期失效问题？消息队列满了以后该怎么处理？有几百万消息持续积压几小时，说说怎么解决？

````
如果是因为消费端异常导致消费速度特别慢,那就需要临时对消费端进行扩容,当然配套的queue也要增加,等到加速消费完MQ后,再恢复原来的消费端
如果是MQ消息积压时间过长导致消息过期丢失,那只能再写程序将丢失的消息查回来,重新写入MQ中将其消费
````

Q2:让你写一个消息队列,该如何进行架构设计?

````
并不是真的写代码,只是提供思路,主要能答出一个消息队列架构中有哪些需要注意的点以及它们的实现思路
本质就是回答你知道的某个消息队列的设计优点有哪些
1.并发性:类似于Kafka的分布式设计,一个topic分成多个partition,每个partition存储在不同的机器上,当需要拓展时,将topic分成更多的partition即可
2.可用性:leader与follower之间的切换
3.持久化:必须保证MQ持久化,提高容灾性.
4.保证消息不丢失:confirm机制
````

### RabbitMQ如何分发消息

见RabbitMQ

### MQ 是用推模型还是拉模型

推模型：优点是实时，缺点是不能匹配消费速度，可能会给消费者带来压力。如果要考虑适配消费速度的推，就会变得复杂，因为消费者要反馈这个信息。

拉模型：优点是使 MQ 设计变得简单，就复杂接收消息和存储消息，消费消息由消费者主动咨询；缺点是实时和空转问题，如果消费者主动拉的时间间隔太短，对 MQ 有压力不说，没有消息时也会造成消费者空转，太长则实时性不好。

RouketMQ 和 Kafka 都采用基于长轮询的拉模型，消费者一般是每间隔 5s 拉取一次，但是如果有消息时，broker 会通知消费者拉取，兼顾了实时性和空转问题。