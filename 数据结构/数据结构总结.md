# 数据结构总结

## 树

### 平衡二叉树

> 树中任何一个节点,它的左子树和右子树的高度差不超过1

AVL树是严格控制平衡的二叉树
红黑树是阉割版的平衡二叉树(最长链和最短链长度不超过2倍关系)
SB树平衡搜索二叉树



### 搜索二叉树

> 树中任何一个节点,左子树所有节点都比它小,右子树所有节点都比它大,默认搜索二叉树不包含重复节点



### 完全二叉树

> 要么是满二叉树,要么除了最底下一层的叶节点之外是满二叉树,并且最底下一层的叶节点必须是按顺序从左到右填,不能跳过.



### 红黑树

特点: 查找树,树的根节点到叶节点的最长路径不超过最短路径的两倍
意义: 避免查找树退化成线性,保证搜索效率
规则: 
	1.所有节点非红即黑,根节点是黑色的
	2.所有叶节点(null)都是黑色的
	3.所有红节点的两个孩子都是黑色的
	4.在任意一条路径上,不能存在两个连续的红节点
	5.所有路径上黑色节点个数相等
变化: 插入一个节点时,按照查找树二分找到它应该插入的位置.如果插入后违反了上述规则的任意一个.
	就要进行变色或旋转操作.常见左旋,右旋的场景要知道



### B(+/*)树

B树是一种多叉搜索树,一个m阶B树中,每个非叶节点最多有m-1个key,有m个指向儿子的指针.其中第0个指针指向key小于第0个key的节点,第m个指针指向key大于第m-1个key的节点.其余的第i个指针指向key范围在第i个~第i+1个之间的节点。如下为一个三阶 B 树：

![img](d:/resource/notePic/524341-20160414100804004-506796201.jpg)

B树的搜索:根据刚才key和指针的规则,如果当前节点中没有目标key,就在它对应的范围指向的下一个节点中去找,一直到叶节点;如果有目标key,就找到返回对应的value.
B树时间复杂度:其时间复杂度趋于log(N)

B+树:B+树与B树的区别,就是B+树的非叶节点不存储key对应的value信息,它们只相当于一个索引节点的作用,所有value信息都存储在叶节点中.并且叶节点中的key都是按照非降序排列

为什么B+树更适合做文件索引结构:
1.其需要的磁盘读写代价更低,因为只有它的叶节点才存储value,其他节点都不需要分配存储value的空间
2.查询效率更稳定,因为所有的value都在叶节点,因此每一个文件的查询都需要走一个树的高度.

B*树:在B+树的基础上,节点增加了指向兄弟的指针

参考:https://yq.aliyun.com/articles/38345



### 二叉树的旋转

对于AVL树和红黑树，当插入/删除数据破坏了平衡性时，需要进行二叉树的旋转

[参考](https://juejin.cn/post/6844904020549730318#heading-7)

左旋：首先断开节点PL与右子节点G的关系，同时将其右子节点的引用指向节点C2；然后断开节点G与左子节点C2的关系，同时将G的左子节点的应用指向节点PL。

理解：左旋目的是为了让减少右子树的高度，核心操作一步是将 root 的右儿子作为新的 newRoot，那自然 root 就成为了 newRoot 的左儿子，所以如果 newRoot 之前就有左儿子的话，它的左儿子应该成为 root 的右儿子（root 调整后一定没有右儿子，因为它原来的右儿子就是 newRoot ）

![img](d:/resource/notePic/16f03bbbf1af8b62tplv-t2oaga2asx-watermark.awebp)

![img](d:/resource/notePic/16f03bbc0657efe3tplv-t2oaga2asx-watermark.awebp)

右旋：首先断开节点G与左子节点PL的关系，同时将其左子节点的引用指向节点C2；然后断开节点PL与右子节点C2的关系，同时将PL的右子节点的应用指向节点G。

![img](d:/resource/notePic/16f03bcaad980624tplv-t2oaga2asx-watermark.awebp)

![img](d:/resource/notePic/16f03baf60bf8024tplv-t2oaga2asx-watermark.awebp)



## 哈希(散列)

### 哈希函数

对于大数据输入，同输入同输出，不同输入均匀分布

### 哈希表

JDK1.8之前，Hash表采用数组链表的结构：数组中存放的是一个链表。JDK1.8之后，Hash表采用数组链表+红黑树的结构，当数组中某个位置的链表长度超过默认值(8)后，就会将该位置的链表变成红黑树，在增删元素的时间消耗和取值的时间消耗中达到了一个较好的平衡。

哈希表数组长度都是2^N^，因为k对a=2^N^取模可以用位运算k&(a-1)，提高了速度。

### 一致性哈希

服务器集群的传统负载均衡策略：对请求进行hash运算，并对服务器个数进行取模，决定这个请求发往哪个服务器。当增/减一台服务器，因为服务器数量发生了变化，所有服务器上的内容都要重新进行hash分配，这样不利于服务器的扩展。

一致性哈希负载均衡策略：将服务器的hostname或ip作为一个字符串,用hash函数处理(处理结果是64位bit),得到不同的结果,这个结果就是作为请求是否前往这个服务器的依据.假设这三个服务器的hash结果分别为[25(m2), 10000(m1), 17890(m3)],那么处理结果的hash结果在17890-25中就由m2负载,在25-10000中就由m1负责,10000-17890中就由m3负责.这样当重新加入一台服务器,假设结果hash值是5000,那么它负责的区域就是25~5000之间,而这些数据之前是由m1负责的,因此只用将m1的这些数据交给它即可,而其他服务器的数据都不用动.

虚拟节点技术：假设为每个服务器生成1000个虚拟节点,3台服务器就有3000个虚拟节点,它们的hash结果分布可以看作是均匀的.这样同一台服务器的虚拟节点看起来是不连续的,但是请求的hash结果落在每台服务器虚拟节点的概率却是均匀的.

![img](d:/resource/notePic/4175425e4164485fbb2d95e6dd80f413tplv-k3u1fbpfcp-watermark.awebp)

### 布隆过滤器

假设有一个URL黑名单,有100亿条(64字节),现在要设置一个过滤器,决定每个URL是否被这个过滤器拦截
分析:如果是从数组中查询,即使100亿条,用二分法查询的时间复杂度也很低,但是要存储这100亿条数据需要640G的内存(10亿字节就是一个G),代价太大.因此需要进行一定提炼,用内存来存储过滤规则而不是数据本身.

原理:假设用一个长度位m的bit数组来存储URL拦截规则的信息,对于一个URL,用hash函数对其计算,并将计算结果对m取模,会得到一个bit数组位置,将这个"描黑"(置1),同一个URL用多个hash函数进行计算,则会得到多个"描黑"位置.依此对每个URL进行这样的操作.就得到了一个长度位m的bit数组,这些数组中有若干位是被"描黑"的.
拦截:同样对这个URL进行多个hash函数运算,如果它的所有结果都是被"描黑"的,那么就认定它被拦截,只要存在一个没有描黑,则不被拦截.

概率:显然这样的方式会存在"错杀"的情况,因为有的白名单URL计算结果可能刚好打到不同黑名单URL的描黑区,但是它一定不会"漏杀"."错杀"的概率和数组m的大小,hash函数的个数K,以及样本的大小N有关.

![1555672412448](d:/resource/notePic/1555672412448.png)

#### 基础类型数组作为bit数组使用

````java
int[] arr = new int[1000];
int intIndex = 30000 / 32; // 找到bit数组中索引为30000的数值在int数组的哪个位置
int  bitIndex = 30000 % 32; // 找到bit数组中索引为30000的数值在int数组中某个位置的哪一位
arr[intIndex] = arr[intIndex] | (1 << bitIndex); // 完成赋值
````

#### 布隆过滤器的三个公式

m是bit数组长度，n是样本元素个数，K是哈希函数个数，P是能接受的最高失误率

m = - n*lnP/(ln2)^2^  

K = ln2*m/n 

P = (1 - e^-nK/m^)^K^ 



