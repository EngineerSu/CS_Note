# 解析逻辑表达式，求解最小逻辑单元计算结果

在一些业务中，有一些业务规则非常灵活，或处于不成熟的易调整阶段，为了让运营能够方便的调整这类业务规则，会出现供类似于策略中心这样的系统。

策略中心的核心功能是能够让运营配置一些表达式，并用配置的表达式组合成策略，策略是否命中对应不一样的业务效果。例子如下：

![image-20210701193528116](d:/resource/notePic/image-20210701193528116.png)

策略的执行可以使用 Groovy 类似的脚本，但是这样的脚本执行只能获取策略表达式的整体结果，当问题排查需要关注哪一个表达式未命中时，就无从下手。

比如以下逻辑：

```java
((1&2)|3) & (4|5)
```

如果最终结果是 false，那么1~5 表达式中哪一个为 false 都有可能导致最终结果为 false，但是 Groovy 类似的脚本计算是得到整体结果。

此时就需要将上述逻辑表达式拆解成计算机的执行顺序，根据计算机的执行顺序，逐个计算表达式，并记录计算结果。

显然上面的表达式并不是计算机的执行顺序，它是中序表达式，运算符在中间，变量在两侧，计算机使用的前序或后序表达式，将上述表达式变成后序表达式，如下：

```java
1#2#&3#|4#5#|&
```

从左往右遍历，每次遇到 `#` 时，将前面变量压栈，遇到 `&` 或 `|`  时，弹栈两个数进行计算后再压栈，直到遍历结束，栈内的唯一值即结果，上述表达式还可以转换成一棵树来存储：

![image-20210701195546493](d:/resource/notePic/image-20210701195546493.png)



注意：

- 后序表达式加 `#` 是作为变量终止符，比如表达式需要如果达到了两位数，如果没有 `#` 则无法区分
- 中序表达式转换为前序、后序表达式：[前序、中序和后序表达式](https://blog.csdn.net/Antineutrino/article/details/6763722)

