## 图

### 图的基础概念和表示方法

[参考](https://www.javazhiyin.com/35233.html)

- G(V, E)表示一个图，G表示一个图，V 是图 G 中顶点的集合，E 是图 G 中边的集合。

- 图不允许没有顶点，但是允许没有边

- 有向边中，是由尾指向头的

- 顶点的度表示和顶点相关边的数量。入度表示以顶点为头的边，出度表示以顶点为尾的边。TD(V) = ID(V) + OD(V)

- 邻接，如果顶点u，v之间存在边(u, v)，则称为两顶点邻接

- 完全图：无向完全图指图中任两个节点之间存在边，有向完全图指图中任两个节点存在互为相反的两条边

- 连通图：任两个顶点之间都存在路径可以走到

- 数组存储：一维数组存储顶点，n * n的二维数组存储边，对于无向图，边的二维数组是对称的；对于有向图，二维数组存储`a[i][j]`表示 i 顶点 => j 顶点，所以每一行不为0的值个数代表了节点 i 的出度，每一列不为0的值个数代表了节点 j 的入度。二维数组中`a[i][j]`的值若为0，表示 i 节点 和 j 节点没有邻接，非零值代表了它们连接的权重值

  ![1566355630944](d:/resource/notePic/1566355630944.png)

  ![1566355660807](d:/resource/notePic/1566355660807.png)

  数组存储存在两个大问题：1.当节点多边少的时候，就会很浪费空间；2.当两个节点之间有多边时，无法存储信息

- 邻接表存储：头节点 + 表节点，头节点存储了所有顶点信息，以及各顶点指向的第一个表节点，假设头节点中的顶点Vi指向了某个表节点，则这个表节点中含有以Vi为尾的头顶点索引，以及这条边的权值，还有指向下一个表节点的指针。

  也就是说，这种存储方式维护了一个所有顶点的数组，数组每个部分可以认为是一个链表，链表的头节点是某个顶点，链表的其他节点是以头节点顶点作尾的头顶点信息，所以链表的长度-1就是出度。

  ![1566359304433](d:/resource/notePic/1566359304433.png)

  ![1566359311992](d:/resource/notePic/1566359311992.png)

  无向图的邻接表

  ![1566359342441](d:/resource/notePic/1566359342441.png)

  ![1566359349433](d:/resource/notePic/1566359349433.png)

  有向图的邻接表

  ![1566359397097](d:/resource/notePic/1566359397097.png)

  ![1566359404338](d:/resource/notePic/1566359404338.png)

  逆邻接表：邻接表是否容易查看有向图各节点的出度，但是不方便统计入度，逆邻接表的建立与邻接表相反，便于统计入度

  ![1566359598127](d:/resource/notePic/1566359598127.png)

- 十字链表：邻接表和逆邻接表都只能查看某个节点的出度或入度，因此引入十字链表，它分为顶点节点和边节点。每个顶点节点有两个位置指针，分别指向第一个以这个顶点为头和为尾的边节点，通过这两个边节点，它可以找到这个顶点所有的出度节点和入度节点。边节点包含两个顶点信息，分别是这个边的头和尾，还包含两个位置指针，指向下一个与该边节点相同的头或尾的边节点。由此每个头节点的顶点经过两次遍历，就可以获取该顶点的出度和入度。

  顶点节点

  ![1566370061217](d:/resource/notePic/1566370061217.png)

  边节点

  ![1566370073447](d:/resource/notePic/1566370073447.png)

  某有向图的十字链表：

  ![1566370089792](d:/resource/notePic/1566370089792.png)

  ![1566370097208](d:/resource/notePic/1566370097208.png)

  可以看到有几条有向边，就有几个边节点。

- 邻接多重表：十字链表对于无向图而言，每条边需要两个节点浪费，所以邻接多重表对其进行了一定改造来适应无向图。重新定义了边节点如下

  ![1566371016784](d:/resource/notePic/1566371016784.png)

  没有头尾的概念，ilink是指针，指向下一个包含ivex顶点的边节点(不一定要在ivex位置)，jlink同理。

  因此头节点也重新定义了，只用指向第一个边节点即可。

  ![1566371343413](d:/resource/notePic/1566371343413.png)

  以下为一个无向图的邻接多重表示例，也是几条边就设置几个边节点

  ![1566371368585](d:/resource/notePic/1566371368585.png)

  ![1566371378031](D:\resource\notePic\1566371378031-16308060272861.png)



### 拓扑排序

拓扑排序是对**有向无圈图**顶点的一种排序，如果存在一条u=>v边，那么在拓扑排序中u必须排在v的前面，拓扑排序描述了图顶点间的一种先后层次关系(比如在选修课程时，有些课程必须先修其他课程才能选修，这就体现了一种层次关系)，它不是唯一的。

拓扑排序的方法：找出图中任一入度为0的顶点，它是目前排序的第一位，然后删除这个顶点以及和这个顶点相关的边，在新图中继续刚才的寻找方法。

拓扑排序的具体实现：首先，扫描一次所有顶点，将入度为0的顶点加到队列queue中。然后，每次都从queue中弹出一个顶点作为当前位置，并扫描所有以弹出顶点为尾的头顶点，将这些头顶点入度-1，如果-1后的入度变成了0，就将这个顶点入列，直到queue为空，就完成了拓扑排序。

[210.课程表II](https://leetcode-cn.com/problems/course-schedule-ii/)

Q：现在你总共有 n 门课需要选，记为 0 到 n-1。

在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们: [0,1]

给定课程总量以及它们的先决条件，返回你为了学完所有课程所安排的学习顺序。

可能会有多个正确的顺序，你只要返回一种就可以了。如果不可能完成所有课程，返回一个空数组。

```
输入: 4, [[1,0],[2,0],[3,1],[3,2]]
输出: [0,1,2,3] or [0,2,1,3]
解释: 总共有 4 门课程。要学习课程 3，你应该先完成课程 1 和课程 2。并且课程 1 和课程 2 都应该排在课程 0 之后。因此，一个正确的课程顺序是 [0,1,2,3] 。另一个正确的排序是 [0,2,1,3] 。
```

A：用上面拓扑排序的思想做，注意的是自定义 GraphNode，它需要的成员属性有哪些（比如本题就只用关注入度数，但是出度得关注节点个数）；另外用一个 map 去存 GraphNode，可以根据课程编号快速找到 GraphNode

```java
class Solution {
    public int[] findOrder(int numCourses, int[][] prerequisites) {
        // 思路：BFS 拓扑排序，首先将所有入度为 0 的节点存进队列
        // 每次从队列中取出一个节点，该节点即拓扑排序选择出来的当前节点，以该节点为尾的头节点入度 -1，如果 -1 后的入度为 0，则节点也入队，直至队列为空
        // 如果队列为空，选择出来的拓扑序列总数不是 n，说明无法完成拓扑排序（有环）

        int[] res = new int[numCourses];
        for (int i = 0; i < numCourses; i++) {
            res[i] = i;
        }
        if (numCourses < 2 || prerequisites == null) {
            return res;
        }

        // key：课程编号；value：课程节点
        Map<Integer, GraphNode> graphMap = new HashMap<>();
        for (int i = 0; i < numCourses; i++) {
            graphMap.put(i, new GraphNode(i));
        }
        // 根据 prerequisites 补充课程节点的拓扑关系
        int row = prerequisites.length;
        for (int i = 0; i < row; i++) {
            GraphNode head = graphMap.get(prerequisites[i][0]);
            GraphNode tail = graphMap.get(prerequisites[i][1]);  
            // 头部的入度数增加
            head.inCount++;          
            // 尾部的出度节点信息增加
            tail.outNodes.add(head);            
        }

        LinkedList<GraphNode> queue = new LinkedList<GraphNode>();
        // 先找出所有入度为 0 的节点入列
        for (Map.Entry<Integer, GraphNode> entry:graphMap.entrySet()) {
            if (entry.getValue().inCount == 0) {
                queue.offer(entry.getValue());
            }
        }
        // 每次从队列中取出一个节点即拓扑排序
        int i = 0;
        while (!queue.isEmpty()) {
            GraphNode node = queue.poll();
            res[i++] = node.val;
            // 取出节点的所有头节点入度 -1，如果 -1 后入度为 0 则入列
            List<GraphNode> outNodes = node.outNodes;
            for (GraphNode each:outNodes) {
                each.inCount--;
                if (each.inCount == 0) {
                    queue.add(each);
                }
            }
        }

        // 如果 res 没填满，说明无法完成拓扑排序
        return i != numCourses ? new int[]{} : res;
    }

    private static class GraphNode {
        // 节点值（这里对应的是课程编号）
        int val;
        // 入度
        int inCount = 0;
        // 出度的节点
        List<GraphNode> outNodes = new ArrayList<>();

        GraphNode(int val) {
            this.val = val;
        }
    }
}
```





### 最短路径算法

对于有向图，指定某个顶点为起点s，计算s到任一顶点的最短路径问题由最短路径算法解决。最短路径还分为无权路径和有权路径，无权路径的路径值就是路径的长度，有权路径的路径值是所有路径上权值的和。有权路径如果存在负值圈(从k顶点到k顶点存在一个路径权值为负数的路径)，那么最短路径问题可能是无解的。

#### 无权最短路径

使用广度优先搜索：优先搜索离起点s最近的每一层的点

使用一个队列queue + 一个布尔数组step（顶点i只要有入列操作，step[i]=true，表示顶点i入列过了，不能再次入列），首先将起点s入列(且无权路径为0)；然后只要队列不为空，每次都从队列中取出一个顶点，并扫描所有以当前取出顶点为尾的头顶点，这些头顶点如果没有入列过(step=false)，就让这些顶点入列(入列时s到它的无权路径即确定=尾顶点无权路径+1)。直到队列是空，就完成了s到所有顶点无权路径的赋值。

最短路径数组 d 的每个值一旦确定，不会再更新



#### 有权最短路径(迪科斯彻dijkstra算法)

这里讨论的路径值没有负数，参考[有权最短路径](https://www.jianshu.com/p/ff6db00ad866)

需要布尔数组known + 路径值数组d + 上一个顶点p 辅助得到顶点s到每一个顶点的最短路径。known标记顶点是否已求出最短路径，d标记顶点目前更新过的可达最短路径，p记录顶点最后一次更新最短路径时的尾顶点(即是从哪一个顶点到当前顶点的)

首先，所有d都为Integer.MAX_VALUE，所有的p都为null

1. 将选择的起点s的known置为true，d置为0，表明这个节点的最短路径值已经可以确定了
2. 寻找所有以s为尾的头顶点，当d(s) + 路径值 < 头顶点d时，更新这些头顶点的d和p(更新为s)
3. 在所有known为false的顶点(记为s1)中，寻找d最小的顶点，将这个顶点的known改为true，表明这个顶点的最小路径值已找到
4. 寻找所有以s1为尾的头顶点，当d(s1) + 路径值 < 头顶点d时，更新这些头顶点的d和p(更新为s1)
5. 重复3步骤

d确定后，只要known还为false，则还可能更新；若known成了true，则不能再更新



### 最小生成树

#### Prim算法

无向图的最小生成树指的是，在无向图的所有边中选定保留若干条边，保证图是连通的且保留边最小的图。

即相当于去除若干条边，不影响图的连通性同时保证去除的边价值最大。因此只有连通图才有最小生成树。

最小生成树的Prim算法和求有权最短路径的dijkstra算法步骤基本一致，区别就是d的含义已经不同：d的含义变成了与顶点连接的最小权值，当有了更新的连接权值，d就更新。

首先，所有d都为Integer.MAX_VALUE，所有的p都为null

1. 将选择的起点s的known置为true，d置为0，表明连接这个顶点s的路径已经可以确定了，不用再更新
2. (无向图)寻找s的所有邻接顶点si，当路径值(s-si) < d(si)时，更新si的d和p(更新为s)
3. 在所有known为false的顶点(记为s1)中，寻找d最小的顶点，将这个顶点的known改为true，表明连接这个顶点的路径已经可以确定了，不用再更新
4. (无向图)寻找s1的所有邻接顶点，重复2步骤

最小生成树如下图

![1566813821926](d:/resource/notePic/1566813821926.png)

Prim算法步骤如下图

![1566813833619](d:/resource/notePic/1566813833619.png)

