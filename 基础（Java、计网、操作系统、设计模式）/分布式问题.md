## 分布式问题

### 如何设计一个高并发系统

高并发系统常用的组件说一波,针对每个组件说一下为什么需要就可以了

````
1.系统拆分:将系统拆分成多个子系统,拆分后使用dubbo进行通信,每个系统可以单独连一个数据库,降低并发
2.缓存:大部分高并发场景都是读多写少,redis缓存单机并发量相比直接走数据库提高了一个数量级.
3.MQ:高并发场景还是会有写操作,利用MQ进行异步和削峰,避免数据库瘫痪
4.分库分表,读写分离:采用主从架构进行分库,读写分离,减轻数据库压力
5.ElasticSearch:分布式搜索引擎,方便扩容,高性能支持高并发
````

### 如何设计一个秒杀系统

[秒杀系统设计-超详细](https://juejin.cn/post/6990307911117307934#heading-25)

```
1.静态页面，cdn 加速；按钮限制点击
2.限流：令牌桶算法比较合适，因为要及时响应
3.缓存：商品数据提前缓存预热。对于不存在的商品查询，限制并发数；或使用布隆过滤器
4.库存：用 redis 去操作库存（先读再改防止超卖），每次操作后发送 MQ 异步下单，实现缓存与数据库的最终一致性。这里需要考虑 redis 修改成功后，发送 MQ 失败的几种情况：
- 发送 MQ 出现异常，这个可以通过异常捕捉去立即补偿 redis
- 机器宕机：挫一点，可以通过日志回捞查看 redis 的操作记录，做数据订正；严谨一点这里要分布式事务
```

### 一般分布式锁有哪些?

Q:一般实现分布式锁都有哪些方式？使用 redis 如何设计分布式锁？使用 zk 来设计分布式锁可以吗？这两种分布式锁的实现方式哪种效率比较高？

````
redis分布锁采用RedLock算法:轮询的在master节点上创建锁,如果创建失败,表明这个节点上有锁.
zk分布式锁是通过创建临时节点的方式,如果创建失败表明有锁,就会注册一个监听器,等待通知获取锁
````

````
redis分布式锁,需要自己不断尝试去获取锁,性能开销较大.获取锁的客户端挂机后,只能等待超时时间释放锁
zk分布式锁不需要不断尝试,获取失败注册一个监听器即可.获取锁的客户端挂了,临时节点没有了,锁会立即释放.
````

### 分布式事务有哪些了解?

Q:分布式事务了解吗？你们是如何解决分布式事务问题的？

#### 2PC

MySQL 可以支持的分布式事务解决方案，尽量保证了数据的一致性，但是实现复杂，牺牲了可用性，对性能影响较大，不适合高并发高性能场景

第一阶段参与者首先在本地执行任务，并将操作成功或失败的结果通知协调者，第二阶段由协调者根据所有参与者的反馈情况，决定各参与者是否要提交操作还是回滚操作。

![图片](/d:/resource/notePic\640.png)

存在的问题：

- 第二阶段等待协调者通知时，参与者都处于阻塞状态
- 若第一阶段都成功，在第二阶段通知过程中，部分参与者超时未收到消息执行回滚，那么就会出现部分成功，部分失败的情况

#### TCC

[参考](https://juejin.cn/post/6936899439625764872)

TCC的思想是使用2阶段提交，try阶段首先尝试各个服务预留资源，如果预留成功则进入commit阶段提交事务，如果有一个服务预留失败，那就进入cancel阶段取消事务。

Try、Confirm、Cancel 3个方法均由业务编码实现。其中Try操作为第一阶段，负责资源的检查和预留；Confirm操作为第二阶段，执行真正的业务操作；Cancel时执行取消（回滚）操作。 

使用TCC时注意要**允许空回滚**：事务协调器在调用TCC服务的一阶段Try操作时，可能会出现因为丢包而导致的网络超时，此时事务协调器会触发二阶段回滚，调用TCC服务的Cancel操作；TCC服务在未收到Try请求的情况下收到Cancel请求，这种场景被称为空回滚；TCC服务在实现时应当允许空回滚的执行。

TTC方案因为需要自己写代码来回滚和补偿,一般很少使用,或者用于金融交易,对事务正确性要求比较高

#### MQ

1. 生产者往MQ发生prepared消息,如果发送成功则开始在本地执行事务.
2. 执行事务成功会往MQ发送confirm消息,MQ收到confirm消息,将消息提供给消费者（如果发送 confirm 失败，MQ 也有机制会回查询问 prepare 的事务是否成功）
3. 消费者如果消费不成功,则需要不断重试.如果一直重试不成功,则消费者本地回滚,也想办法通知A本地回滚.如果实在不方便本地回滚,可以报警申请人工干预.





### 分布式session

Q:集群部署时的分布式 session 如何实现？

````
spring+redis:在spring中进行一定的配置,使用redis存储session,在spring中使用session还是和本地使用方式一样,但是spring是从redis中获取数据
````

### 如何实现SSO(Single Sign On, 单点登录)

SSO的概念简单来说, 就是"一次登录,多次访问", 对于一个含有多个子系统的系统, 只用登录一个子系统, 就可以免登录访问其他子系统.

它的实现是创建一个SSO认证中心, 每次请求来时, 可以使用spring的拦截器拦截请求, 重定向到认证中心检查该请求cookie中是否有token, 若没有则需要登录, 若有则放行.

登录了一次后, 会把token写回到cookie中, 并且设置cookie的domain, 保证访问其他子系统时也会将token带过去.

(认证中心可以认为是一个分布式session的平台, 可以用redis实现)



### CAP 和 BASE

[CAP定理](https://juejin.im/post/5b26634b6fb9a00e765e75d1)

是指在分布式系统中：

- 一致性C：所有分区数据保持一致
- 高可用性A：每个操作都必须以可预期的响应结束
- 分区容错性P：即使出现单个组件不可用,操作依然可以完成

不能够同时保证，因为对于分布式系统，一般都需要分区，所以P一般都是要保证的。

![1566956228344](d:/resource/notePic/1566956228344.png)

上图是正常的情况，在发生网络故障时，N1的数据库改变V1无法立即同步到N2中，此时为了保障分区容错性，要么牺牲一致性C，直接用B本地未同步的V0返回结果；要么牺牲高可用A，等待网络恢复后再返回结果。因此常见的组合就是AP 或 CP

![1566956345119](d:/resource/notePic/1566956345119.png)

一般的分布式系统都是采用AP，因为一般可用性对用户体验更重要。而涉及财产方面的系统一般是CP，它们对一致性要求较高，即使暂时不提供服务也没关系。



#### BASE 理论

- Basically Available（基本可用）
- Soft state（软状态）
- Eventually consistent（最终一致性）

BASE理论是对CAP中的一致性和可用性进行一个权衡的结果，理论的核心思想就是：**我们无法做到强一致，但每个应用都可以根据自身的业务特点，采用适当的方式来使系统达到最终一致性**（Eventual consistency）。



### Raft-分布式系统的算法

[参考](https://juejin.cn/post/6907151199141625870#heading-5)

Raft是一个保证AP的分布式系统，不保证强一致性，但是保证最终一致性。

最开始，所有节点都是follwer，当超过 election timeout 的时间没有收到 leader 的心跳，就会进入candidate状态，往其它节点发送选举请求。为了避免多个 follwer 同时发起选举请求，election timeout 是随机的，一般在 150ms-300ms 之间。

选举过程遵循以下规则：

- 每个follower只能投一票，并且先到先得。即可能有多个candidate往某个follower发送选举请求，follower只会投票给选举请求最先到达的candidate，并且投完票的 follower 的 election timeout 会重新开始计时
- 每个follower只会投票给log比自己更新的candidate，即candidate发送选举请求时，需要附带自己的log信息，log信息如果不比follower新，follower不会给该candidate投票

当某个 follower 收到半数以上其它 follower 的选票，它就会变成 leader，开始给所有 follower 发送心跳信息，其它 follower 或竞选者收到消息后，自动变成 fllower 重新开始 election timeout 的计时。

每一次选举结束后，整个分布式系统进入了一个新的term(任期)，旧 term 的 leader 如果恢复后，收到新 leader 的心跳消息，会自动变成 follower 并开始同步消息。

若因为网络分割，可能会导致出现不同的leader。比如ABCDEF，AB和CDEF网络不同，CDEF收不到原leader的消息，可能会重新选举出C作为CDEF的leader，CDEF进入了更新的term，AB则停留在旧term。

此时客户端发送请求时，若请求到A，A同步log到B，显然达不到大多数，所以此时A的log不会提交。但是若请求打到C，因为它是可以同步到大多数的，所以它的log会提交。当网络恢复时，因为AB所在term比CDEF旧，所以A会自动变成follower，并且回滚没有提交的log，再与C的log同步。