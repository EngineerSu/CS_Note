## JVM调优

### JVM参数

```java
-Xms3072M JVM启动时申请的堆初始大小
-Xmx3072M JVM可申请的堆最大内存
-Xmn2048M 堆中年轻代内存大小(年轻代指定后,老年代=堆总大小 - 年轻代 - 永久代)
-Xss1M Java每个线程堆栈大小
-XX:PermSize=256M 永久代初始大小
-XX:MaxPermSize=256M 永久代的最大内存
-XX:SurvivorRatio=8 Eden区:新生代=8:10(剩下的2/10两个S区1:1)
-XX:MaxTenuringThreshold=5 新生代里躲过了5次MinorGC就会进入老年代
-XX:PretenureSizeThreshold=1M 大于1M的对象会进入老年代
-XX:+UseParNewGC 新生代使用ParNew垃圾收集器
-XX:+UseConcMarkSweepGC 老年代使用CMS垃圾收集器
```

### JVM调优规则

FullGC对程序的影响比较明显, 所以尽量增大两次FullGC的时间. 核心思想就是: 真正长期存活对象尽快进入老年代, 非长期存活对象不要进入老年代

### FullGC的触发条件

- 老年代剩余内存大小 少于 MinorGC后平均存活对象大小
- 老年代剩余内存大小 少于 S区的内存大小

### 对象进入老年代的情况

- 大对象: 规定超过PretenureSizeThreshold的对象会进入老年代
- 长期存活的对象: 躲过了MaxTenuringThreshold次MinorGC的对象会进入老年代
- 大比例同龄对象: 一次MinorGC后存活的同龄对象, 如果内存超过了Survivor区一般大小, 也可能进入老年代

### JVM调优实例

- 预估内存模型, 估计系统每秒占用的内存大小

    比如电商平台, 假设每秒300订单, 每个订单1KB, 算上与订单有关的支付 / 优惠券 / 库存等其他系统, 可能占用情况扩大200倍, 那么每秒就是300*200KB, 约60MB

- 初步分配新生代(Eden/S1/S2)和老年代的大小

    比如计算机的内存是8G, 那么除开操作系统, 给JVM的有4G, 堆分配3G, 永久代分配256M, 剩下的内存留给线程的Java虚拟机栈. 

    堆中新生代和老年代各1.5G, 新生代中Eden:S1:S2=8:1:1, 所以Eden区就是1.2G. 两个S区都是150M

- 预估多久一次MinorGC, 以及MinorGC后存活对象大小

    根据前面预估, 每秒60M内存, 1.2G可以支持大约20s. 每秒订单处理完成后, 它占用的60M内存就基本都是垃圾, 所以假设存活对象有1%, 加上MinorGC时产生的对象, MinorGC后存活对象有100M, 这100M会进入S1区. 

    由于MinorGC后存活的100M是同龄对象, 进入150M的S区, 超过了S区一半大小, 因此这些对象可能会进入老年代, 这样每次MinorGC后对象都进入老年代肯定是不行的, 会很快触发FullGC(老年代)

- 如果发现初步分配的新生代大小不合适, 需要重新分配

    由上一步分析, S区内存相对较小, 可以将新生代分配为2G内存, 还是8:1:1. 那么S区大小有200M, 相当来说情况就会好一些

- 选择合适的动态年龄

    默认动态年龄是15, 即躲过了15次MinorGC还没有被回收则进入老年代. 但是这里一次MinorGC的时间是25s左右, 15次其实太久了, 可以调整为5次, 也就是存活超过2min的对象, 进入老年代, 这是较合理的.

- 选择合适的垃圾收集器

### 调优指南

- 编程时控制变量范围, 避免定义不必要的全局变量
- 合理分配新生代和Survivor区的内存大小, 使MinorGC良性循环: 减少因为Survivor区放不下进入老年代的情况
- 合理设置动态年龄, 太大会占用新生代大小, 导致后面的MinorGC存活对象容易因为S区放不下误入老年代, 太小会直接导致没必要进入老年代的对象误入



